--- /dev/null
+++ b/client/checkfile.c
@@ -0,0 +1,137 @@
+/*
+ * Test file object checksum against a file on the system
+ *
+ * Written by Bill MacAllister <whm@dropbox.com>
+ * Copyright 2020 Dropbox, Inc.
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+#include <config.h>
+#include <portable/system.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+#include <client/internal.h>
+#include <util/messages.h>
+#include <util/xmalloc.h>
+
+#include <stdlib.h>
+#include <string.h>
+#include <openssl/md5.h>
+
+/* Given a string and its length return a checksum for the string.
+ */
+char *checkfile_str2md5(const char *str, int length) {
+    int n;
+    MD5_CTX c;
+    unsigned char digest[16];
+    char *out = (char*)malloc(33);
+
+    MD5_Init(&c);
+
+    while (length > 0) {
+    if (length > 512) {
+        MD5_Update(&c, str, 512);
+    } else {
+        MD5_Update(&c, str, length);
+    }
+    length -= 512;
+    str += 512;
+    }
+
+    MD5_Final(digest, &c);
+
+    for (n = 0; n < 16; ++n) {
+    snprintf(&(out[n*2]), 16*2, "%02x", (unsigned int)digest[n]);
+    }
+
+    return out;
+}
+
+/*
+ * Read all of a file into memory and return the contents in newly allocated
+ * memory.  Returns the size of the file contents in the second argument if
+ * it's not NULL.  Dies on any failure.
+ */
+void *
+checkfile_read_file(const char *name, size_t *length)
+{
+    char *contents;
+    size_t size, offset;
+    int fd;
+    struct stat st;
+    ssize_t status;
+
+    fd = open(name, O_RDONLY);
+    if (fd < 0)
+    return NULL;
+    if (fstat(fd, &st) < 0)
+      return NULL;
+    size = st.st_size;
+    contents = xmalloc(size);
+
+    offset = 0;
+    do {
+    if (offset >= size - 1) {
+        size += BUFSIZ;
+        contents = xrealloc(contents, size);
+    }
+    do {
+        status = read(fd, contents + offset, size - offset - 1);
+    } while (status == -1 && errno == EINTR);
+    if (status < 0)
+        sysdie("cannot read from file");
+    offset += status;
+    } while (status > 0);
+    close(fd);
+    if (length != NULL)
+    *length = offset;
+    return contents;
+}
+
+/*
+ * Given a remctl object, the command prefix, object type, and object name,
+ * and a file calculate the checksum of the file, get the checksum of
+ * the wallet object, and compare them.  Returns 0 if the checksums
+ * match and an exit status on if the don't match.
+ */
+int
+checkfile(struct remctl *r, const char *prefix, const char *type,
+     const char *name, const char *file)
+{
+    const char *command[5];
+    char *file_data = NULL;
+    char *file_checksum = NULL;
+    size_t count, length;
+    char *wallet_checksum = NULL;
+    size_t wallet_length = 0;
+    int status;
+
+    /* Check to see if the file exists.  It not return mismatch status */
+    file_data = checkfile_read_file(file, &length);
+    if (file_data == NULL)
+    return 1;
+
+    command[0] = prefix;
+    command[1] = "checksum";
+    command[2] = type;
+    command[3] = name;
+    command[4] = NULL;
+    status = run_command(r, command, &wallet_checksum, &wallet_length);
+    if (status != 0)
+    return status;
+
+    /* If the wallet object is empty or NULL return mismatch and let the
+     * subsequent call to file handle the error condition of an empty
+     * file object.
+     */
+    if ((wallet_length == 0) || (wallet_checksum == NULL))
+    return 1;
+
+    file_checksum = checkfile_str2md5(file_data, strlen(file_data));
+
+    return strcmp(file_checksum, wallet_checksum);
+}
--- a/client/wallet.c
+++ b/client/wallet.c
@@ -172,6 +172,14 @@ main(int argc, char *argv[])
         if (argc > 2)
             die("too many arguments");
         status = rekey_keytab(r, ctx, options.type, argv[1]);
+    } else if (strcmp(argv[0], "checkfile") == 0) {
+        if (argc > 3)
+            die("too many arguments");
+        if (strcmp(argv[1], "keytab") == 0)
+            die("checkfile command is not valid for keytabs");
+        status = checkfile(r, options.type, argv[1], argv[2], file);
+        if (status > 0)
+            status = get_file(r, options.type, argv[1], argv[2], file);
     } else {
         count = argc + 1;
         if (strcmp(argv[0], "store") == 0) {
--- a/client/wallet.pod
+++ b/client/wallet.pod
@@ -263,7 +263,14 @@ already exist.
 Check whether an object of type <type> and name <name> already exists.  If
 it does, prints C<yes>; if not, prints C<no>.
 
-=item checksum
+=item checkfile <type> <name>
+
+Preforms a get command only if the wallet object checksum differs from
+the checksum of the file specified.  The -f switch must be specified.
+This command is not valid for keytabs and the wallet object must have
+been stored.
+
+=item checksum <type> <name>
 
 Returns the checksum for file objects.
 
--- a/client/internal.h
+++ b/client/internal.h
@@ -97,6 +97,15 @@ int get_file(struct remctl *, const char
              const char *name, const char *file);
 
 /*
+ * Given a remctl object, the command prefix, object type, and object name,
+ * and a file calculate the checksum of the file, get the checksum of
+ * the wallet object, and compare them.  Returns 0 if the checksums
+ * match and an exit status on if the don't match.
+ */
+int checkfile(struct remctl *r, const char *prefix, const char *type,
+              const char *name, const char *file);
+
+/*
  * Given a remctl object, the Kerberos context, the type for the wallet
  * interface, the name of a keytab object, and a file name, call the correct
  * wallet commands to download a keytab and write it to that file.  If srvtab
--- a/Makefile.am
+++ b/Makefile.am
@@ -150,7 +150,8 @@ util_libutil_a_CPPFLAGS = $(KRB5_CPPFLAG
 # The private library used by both wallet and wallet-rekey.
 noinst_LIBRARIES += client/libwallet.a
 client_libwallet_a_SOURCES = client/file.c client/internal.h client/keytab.c \
-	client/krb5.c client/options.c client/remctl.c client/srvtab.c
+	client/krb5.c client/options.c client/remctl.c client/srvtab.c \
+	client/checkfile.c
 client_libwallet_a_CPPFLAGS = $(REMCTL_CPPFLAGS) $(KRB5_CPPFLAGS)
 
 # The client and server programs.
